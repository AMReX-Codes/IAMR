#
# amrlib sources
#
AMR_C_SOURCES = main.cpp Amr.cpp AmrLevel.cpp BCRec.cpp Cluster.cpp \
                Derive.cpp ErrorList.cpp FluxRegister.cpp \
                Interpolater.cpp RunStats.cpp StateData.cpp \
                StateDescriptor.cpp TagBox.cpp

AMR_C_HEADERS = Amr.H AmrLevel.H BCRec.H Cluster.H Derive.H \
                ErrorList.H FluxRegister.H Interpolater.H \
                LevelBld.H RunStats.H StateData.H StateDescriptor.H 

AMR_F_SOURCES = INTERP_$(DIM)D.F FLUXREG_$(DIM)D.F FILCC_$(DIM)D.F 
AMR_F_HEADERS = INTERP_F.H BC_TYPES.H PROB_AMR_F.H FLUXREG_F.H

CEXE_sources += $(AMR_C_SOURCES)
CEXE_headers += $(AMR_H_HEADERS)

FEXE_sources += $(AMR_F_SOURCES)
FEXE_headers += $(AMR_F_HEADERS)
#
# bndrylib sources
#
BNDRYLIB_BASE=EXE
C$(BNDRYLIB_BASE)_sources += FabSet.cpp BndryRegister.cpp \
			     Geometry.cpp CoordSys.cpp RealBox.cpp
C$(BNDRYLIB_BASE)_headers += FabSet.H BndryRegister.H \
			     Geometry.H CoordSys.H RealBox.H

F$(BNDRYLIB_BASE)_headers += COORDSYS_F.H DIMS.H
F$(BNDRYLIB_BASE)_sources += COORDSYS_$(DIM)D.F
#
# boxlib sources
#
BOXLIB_BASE=EXE
 
C$(BOXLIB_BASE)_sources += BoxLib.cpp Tracer.cpp
C$(BOXLIB_BASE)_headers += BoxLib.H BLVERSION.H Tracer.H

C$(BOXLIB_BASE)_sources += ParmParse.cpp Utility.cpp aString.cpp BArena.cpp
C$(BOXLIB_BASE)_headers += ParmParse.H Utility.H Assert.H aString.H

C$(BOXLIB_BASE)_headers += ArrayLim.H REAL.H Boolean.H SPACE.H SPACE_F.H
C$(BOXLIB_BASE)_headers += CONSTANTS.H BArena.H Arena.H UseCount.H

C$(BOXLIB_BASE)_sources += DistributionMapping.cpp ParallelDescriptor.cpp
C$(BOXLIB_BASE)_headers += DistributionMapping.H ParallelDescriptor.H

C${BOXLIB_BASE}_sources += FabConv.cpp FPC.cpp BoxAssoc.cpp FArrayBox.cpp
C${BOXLIB_BASE}_headers += FabConv.H FPC.H BoxAssoc.H FArrayBox.H

C$(BOXLIB_BASE)_sources += Box.cpp IntVect.cpp IndexType.cpp Orientation.cpp
C$(BOXLIB_BASE)_headers += Box.H IntVect.H IndexType.H Orientation.H

C$(BOXLIB_BASE)_sources += BoxList.cpp BoxArray.cpp BoxDomain.cpp MultiFab.cpp
C$(BOXLIB_BASE)_headers += BoxList.H BoxArray.H BoxDomain.H Looping.H MultiFab.H

T_sources += Array.cpp PArray.cpp List.cpp Pointers.cpp Tuple.cpp
T_headers += Array.H PArray.H List.H Pointers.H Tuple.H Misc.H

T_sources += BaseFab.cpp ArithFab.cpp OrderedFab.cpp NormedFab.cpp FabArray.cpp
T_headers += BaseFab.H ArithFab.H OrderedFab.H NormedFab.H FabArray.H
#
# multigrid sources
#
MGLIB_BASE=EXE
C$(MGLIB_BASE)_headers += ABecLaplacian.H BndryData.H BoundCond.H \
                          CGSolver.H InterpBndryData.H LO_BCTYPES.H \
                          Laplacian.H LinOp.H Mask.H MultiGrid.H \
                          WriteMultiFab.H

C$(MGLIB_BASE)_sources += ABecLaplacian.cpp BndryData.cpp CGSolver.cpp \
                          InterpBndryData.cpp Laplacian.cpp LinOp.cpp \
                          Mask.cpp MultiGrid.cpp WriteMultiFab.cpp

F$(MGLIB_BASE)_headers += ABec_F.H CG_F.H INTERPBNDRYDATA_F.H \
                          LO_F.H LP_F.H MG_F.H

F$(MGLIB_BASE)_sources += ABec_$(DIM)D.F CG_$(DIM)D.F \
                          INTERPBNDRYDATA_$(DIM)D.F LO_$(DIM)D.F \
                          LO_UTIL.F LP_$(DIM)D.F MG_$(DIM)D.F
#
# BSP stuff
#
ifeq ($(USE_BSP),TRUE)
CEXE_sources += preload.cpp
endif
#
# IAMR sources:  _run2d
#
CEXE_sources += NS_setup.cpp NSBld.cpp
FEXE_headers += probdata.H PROB_F.H
ifeq ($(DIM),2)
FEXE_sources += PROB_2D.F 
endif
ifeq ($(DIM),3)
FEXE_sources += PROB_3D.F 
endif
#
# IAMR sources:  _bndry
#
CEXE_sources += SyncRegister.cpp  ViscBndry.cpp  MacBndry.cpp 
ifeq ($(DIM),2)
CEXE_sources += ViscBndry2D.cpp
endif

CEXE_headers += SyncRegister.H  RegType.H  ViscBndry.H  MacBndry.H 
ifeq ($(DIM),2)
CEXE_headers += ViscBndry2D.H
endif

FEXE_headers += SYNCREG_F.H VISCOPERATOR_F.H
FEXE_sources += SYNCREG_$(DIM)D.F VISCOPERATOR_$(DIM)D.F
#
# Disconnect MacOperators for different mass continuity
#
ifndef ATMOS_MACOP
CEXE_sources += MacOperator.cpp
CEXE_headers += MacOperator.H
FEXE_sources += MACOPERATOR_$(DIM)D.F
FEXE_headers += MACOPERATOR_F.H
endif
#
# IAMR sources:  _ns_mac_new
#
CEXE_sources += Projection.cpp MacProj.cpp Godunov.cpp Diffusion.cpp NavierStokes.cpp 
CEXE_headers += Projection.H MacProj.H Godunov.H Diffusion.H NavierStokes.H 
						                   
FEXE_sources += DERIVE_$(DIM)D.F GODUNOV_F.F GODUNOV_$(DIM)D.F NAVIERSTOKES_$(DIM)D.F \
		PROJECTION_$(DIM)D.F MACPROJ_$(DIM)D.F DIFFUSION_$(DIM)D.F 

FEXE_headers += DERIVE_F.H GODUNOV.FH GODUNOV_F.H PROJECTION_F.H MACPROC_F.H \
		DIFFUSION_F.H NAVIERSTOKES_F.H 
#
# HGPROJ sources
#
LBASE=proj
#LBASE=ell

ifeq ($(LBASE),proj)
CEXE_sources += cache.cpp interface.cpp boundary.cpp interpolator.cpp \
       		restrictor.cpp fill_patch.cpp amr_multi.cpp \
		hg_multi1.cpp hg_multi2.cpp hg_multi3.cpp \
		hg_projector.cpp
ifeq	($(USE_WINDOWS),TRUE)
CEXE_sources +=	amr_graph.cpp
FEXE_sources += cont$(DIM)d.F
endif
CEXE_headers += cache.H interface.H boundary.H interpolator.H restrictor.H \
                fill_patch.H amr_graph.H amr_multi.H hg_multi.H hg_projector.H
FEXE_sources += amr_real$(DIM)d.F \
                hg_multi$(DIM)d.F hg_proj$(DIM)d.F hg_avg$(DIM)d.F
FEXE_headers +=
endif

ifeq ($(LBASE),ell)
CEXE_sources += amr_multi.cpp hg_multi1.cpp hg_multi2.cpp hg_multi3.cpp \
		hg_elliptic.cpp amr_gravity.cpp
CEXE_headers += amr_multi.H hg_multi.H hg_elliptic.H amr_gravity.H
FEXE_sources += hg_multi$(DIM)d.F amr_grav$(DIM)d.F
FEXE_headers +=
endif

ifeq ($(EBASE),driver)
CEXE_sources += driver.cpp
endif

ifeq ($(EBASE),proj)
CEXE_sources += proj.cpp
endif

ifeq ($(EBASE),poisson)
CEXE_sources += poisson.cpp
endif

ifeq ($(USE_ARRAYVIEW),TRUE)
CEXE_sources += DatasetClient.cpp
endif
